---
title: "RISC"
author: "YinCY"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# RISC: robust integration of single-cell RNA-seq datasets using a single reference space

## Introduction
```{r}
library(RISC)
library(RColorBrewer)
library(magrittr)

data("raw.mat")
raw.mat %>% class()
raw.mat %>% length()

mat0 <- raw.mat[[1]]
coldata0 <- raw.mat[[2]]

coldata1 <- coldata0[coldata0$Batch0 == "Batch1", ]
coldata2 <- coldata0[coldata0$Batch0 == "Batch2", ]
coldata3 <- coldata0[coldata0$Batch0 == "Batch3", ]
coldata4 <- coldata0[coldata0$Batch0 == "Batch4", ]
coldata5 <- coldata0[coldata0$Batch0 == "Batch5", ]
coldata6 <- coldata0[coldata0$Batch0 == "Batch6", ]

mat1 <- mat0[, rownames(coldata1)]
mat2 <- mat0[, rownames(coldata2)]
mat3 <- mat0[, rownames(coldata3)]
mat4 <- mat0[, rownames(coldata4)]
mat5 <- mat0[, rownames(coldata5)]
mat6 <- mat0[, rownames(coldata6)]
```


## Heterogeneous Simulated data
### Create RISC objects
We generate RISC objects from the gene-cell matrix (mat), the data frame of the cells (coldata), and the data frame of the genes, using "readsc" function. The RISC objects can also be generated by 'read10X_mtx' or 'read10X_h5' function for 10X Genomics data.

```{r}
sce1 <- readsc(count = mat1, 
               cell = coldata1, 
               gene = data.frame(Symbol = rownames(mat1), 
                                 row.names = rownames(mat1)), 
               is.filter = F)

sce2 <- readsc(count = mat2, 
               cell = coldata2, 
               gene = data.frame(Symbol = rownames(mat2), 
                                 row.names = rownames(mat2)), 
               is.filter = F)
sce3 <- readsc(count = mat3, 
               cell = coldata3, 
               gene = data.frame(Symbol = rownames(mat3), 
                                 row.names = rownames(mat3)), 
               is.filter = F)
sce4 <- readsc(count = mat4, 
               cell = coldata4, 
               gene = data.frame(Symbol = rownames(mat4), 
                                 row.names = rownames(mat4)), 
               is.filter = F)
sce5 <- readsc(count = mat5, 
               cell = coldata5, 
               gene = data.frame(Symbol = rownames(mat5), 
                                 row.names = rownames(mat5)), 
               is.filter = F)
sce6 <- readsc(count = mat6, 
               cell = coldata6, 
               gene = data.frame(Symbol = rownames(mat6), 
                                 row.names = rownames(mat6)), 
               is.filter = F)
```


### Processing RISC data
After create RISC objects, we next process the RISC data, here we show the standard processes: (1) filter the cells, remove cells with extremely low or high UMIs and discard cells with extremely low number of expressed genes. Here we use simulated data, so we do not filter out any cell. (2) normalize gene expression, removing the effect of RNA sequencing depth. (3) scale gene expression, the scaled counts merely contain gene signal information for individual cells, and yield column-wise zero empirical mean for each column, thus satisfying the requirement for PCA and SVD. (4) find highly variable genes, identify highly variable genes by Quasi-Poisson model and utilize them for gene-cell matrix decomposition and data integration.

```{r}
process0 <- function(obj0){
    # filter cells
    obj0 <- scFilter(obj0, min.UMI = 0, max.UMI = Inf, min.gene = 10, min.cell = 3, is.filter = F)
    
    # normalize data
    obj0 <- scNormalize(obj0, method = "robust")
    
    # find highly variable genes
    obj0 <- scDisperse(obj0)
    
    # replace highly variable genes by all the genes for integration
    obj0@vargene <- rownames(sce1@rowdata)
    
    return(obj0)
}


sce1 <- process0(sce1)
sce2 <- process0(sce2)
sce3 <- process0(sce3)
sce4 <- process0(sce4)
sce5 <- process0(sce5)
sce6 <- process0(sce6)
```


### RPCI integration
The core principle of RPCI is very different from existing methods, RPCI introduces an effective formula to calibrate cell similarity by a global reference, and directly projects all cells into a reference RPCI space.

```{r}
set.seed(1)
var.genes <- rownames(sce1@assay$logcount)
pcr0 <- list(sce1, sce2, sce3, sce4, sce5, sce6)
pcr0 <- scMultiIntegrate(pcr0, eigens = 9, var.gene = var.genes, align = "OLS", npc = 12)
# pcr0 <- scLargeIntegrate(pcr0, var.gene = var.genes, align = "Predict", npc = 8)
pcr0 <- scUMAP(pcr0, npc = 9, use = "PLS", dist = 0.001, neighbors = 15)
```

```{r}
pcr0 %>% class()
```



```{r}
pcr0@coldata$Group <- factor(pcr0@coldata$Group0, levels = c("Group1", "Group2", "Group2*", "Group3", "Group3*"), 
                             labels = c("a", "b", "b'", "c", "c'"))

pcr0@coldata$Set0 <- factor(pcr0@coldata$Set, levels = c("Set1", "Set2", "Set3", "Set4", "Set5", "Set6"), 
                            labels = c("Set1 rep.1", "Set2 rep.1", "Set3 rep.1", "Set1 rep.2", "Set2 rep.2", "Set3 rep.2"))

pcr0 <- scCluster(pcr0, 
                  slot = "cell.umap", 
                  k = 4, 
                  method = "density", 
                  dc = 0.3)
```


### UMAP plot
```{r}
DimPlot(pcr0, colFactor = "Set0", size = 2)
```

```{r}
DimPlot(pcr0, colFactor = "Group", size = 2, Colors = brewer.pal(5, "Set1"))
```

```{r}
DimPlot(pcr0, colFactor = "Cluster", size = 2, Colors = brewer.pal(4, "Dark2"))
```
















