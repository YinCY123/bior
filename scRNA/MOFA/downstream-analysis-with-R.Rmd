---
title: "downstream-analysis-with-R"
author: "yincy"
date: "6/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library(MOFA2)
library(ggplot2)
```


# Downstream analysis
## Introduction
In the MOFA2 R package we provide a wide range of downstream analysis to visualise and interpret the model output. Here we provide a brief description of the main functionalities. This vignette is made of simulated data and we do not highlight biologically relevant results. Please see our [tutorials](https://biofam.github.io/MOFA2/tutorials.html) for real use cases.  

## Load libraries
```{r}
library(ggplot2)
library(MOFA2)
```

## Load trained model
```{r}
filepath <- system.file("extdata", "model.hdf5", package = "MOFA2")
model <- load_model(filepath)
```

### Overview of data
The function `plot_data_overview` can be used to obtain an overview of the input data. It shows how many views (rows) and how many groups (columns) exist, what are their corresponding dimensionalities and how many missing information they have (grey bars).  

```{r}
plot_data_overview(model)
```

## Add metadata to the model

The metadata is stored as a data.frame object in `model@samples_metadata`, and it requires at least the column `sample`. The column `group` is required only if you are doing multi-group inference.  

The number of rows must match the total number of samples in the model (`sum(model@dimensions$N)`).  

Let's add some artifical metadata  
```{r}
Nsamples <- sum(get_dimensions(model)[["N"]])

sample_metadata <- data.frame(
    sample = samples_names(model)[[1]], 
    condition = sample(c("A", "B"), size = Nsamples, replace = T),
    age = sample(1:100, size = Nsamples, replace = T)
)

samples_metadata(model) <- sample_metadata
samples_metadata(model) %>% head
```

## Variance decomposition
The first step in the MOFA analysis is to quantify the amount of variance explained (R2) by each factor in each data modality.  

The variance explained estimates are stored in the hdf5 file and loaded in `model@cache[["variance_explained"]]`:  

```{r}
# total variance explained per view
get_variance_explained(model)$r2_total[[1]] 
```

```{r}
# variance explained for every factor in per view
get_variance_explained(model)$r2_per_factor[[1]]
```

Variance explained estimates can be plotted using `plot_variance_explained(model, ...)`. Options:  

- **factors**: character vector with a factor name(s), or numeric vector with the index(es) of the factor(s). Default is "all".  
- **x**: character specifying the dimension for the x-axis ("view", "factor", or "group").  
- **y**: character specifying the dimension for the y-axis ("view", "factor", or "group").  
- **split_by**: character specifying the dimension to be faceted ("view", "factor", or "group").  
- **plot_total**: logical value to indicate if to plot the total variance explained (for the variable in the x-axis)  

In this case we have 5 active factors that explain a large amount of variance in both data modalities.  

```{r}
plot_variance_explained(model, x = "view", y = "factor")
```

The model explains ~70% of the variance in both data modalities.  

```{r}
plot_variance_explained(model, x="view", y="factor", plot_total = TRUE)[[2]] +
    scale_y_continuous(limits = c(0, 80))
```

## Visualization of Factors
The MOFA factors capture the global sources of variability in the data. Mathematically, each factor ordinates cells along a one-dimensional axis centered at zero. The value per se is not important, only the relative positioning of samples matters. Samples with different signs manifest opposite “effects” along the inferred axis of variation, with higher absolute value indicating a stronger effect. Note that the interpretation of factors is analogous to the interpretation of the principal components in PCA.  

### Visualization of factors one at a time
Factors can be plotted using `plot_factor` (for beeswarm plots of individual factors) or `plot_factors` (for scatter plots of factor combinations).  

```{r}
plot_factor(model, 
            color_by = "age", 
            factor = 1:3, 
            shape_by = "condition")
```

Adding more options

```{r}
p <- plot_factor(model, 
                 factors = c(1, 2, 3), 
                 color_by = "condition", 
                 dot_size = 3, 
                 dodge = TRUE, 
                 legend = FALSE, 
                 add_violin = T, 
                 violin_alpha = 0.25) 

p <- p +
    scale_color_manual(values = c("A" = "black", "B" = "red")) +
    scale_fill_manual(values = c("A" = "black", "B" = "red"))

p
```

### Visualization of combinations of factors
scatter plots

```{r}
plot_factors(model, 
             factors = 1:3, 
             color_by = "condition")
```

## Visualization of feature weights

The weights provide a score for how strong each feature relates to each factor. Features with no association with the factor have values close to zero, while features with strong association with the factor have large absolute values. The sign of the weight indicates the direction of the effect: a positive weight indicates that the feature has higher levels in the cells with positive factor values, and vice versa.  

Weights can be plotted using `plot_weights` or `plot_top_weights`  

```{r}
plot_weights(model, 
             view = "view_1", 
             factors = 1, 
             nfeatures = 10, 
             scale = TRUE, 
             abs = F)
```

```{r}
plot_top_weights(model, 
                 view = "view_0", 
                 factor = 1, 
                 nfeatures = 10)
```

## Visualization of covariation patterns in the input data
Instead of looking at weights, it is useful to observe the coordinated heterogeneity that MOFA captures in the original data. This can be done using the `plot_data_heatmap` and  `plot_data_scatter` function.  

### Heatmaps
Heatmap of observations. Top features are selected by its weight in the selected factor. By default, samples are ordered according to their corresponding factor value.  

```{r}
plot_data_heatmap(model, 
                  factor = 1, 
                  view = "view_0",
                  features = 20, 
                  cluster_rows = T,
                  cluster_cols = F, 
                  show_rownames = T, 
                  show_colnames = F, 
                  col = viridis::viridis(20, option = "A", begin = 0, end = 1))
```


### Scatter plots
Scatter plots of observations vs factor values. It is useful to add a linear regression estimate to visualise if the relationship between (top) features and factor values is linear.  

```{r}
plot_data_scatter(model, 
                  view = "view_1", 
                  factor = 1, 
                  features = 5, 
                  add_lm = TRUE, 
                  color_by = "condition")
```

### Non-linear dimensionality reduction
The MOFA factors are linear (as in Principal Component analysis), so each one captures limited amount of information, but they can be used as input to other methods that learn compact nonlinear manifolds, e.g. t-SNE or UMAP.

Run UMAP or t-SNE  

```{r}
set.seed(42)
model <- run_umap(model)
model <- run_tsne(model)
```

```{r}
plot_dimred(model, 
            method = "TSNE", 
            color_by = "condition", 
            dot_size = 5)
```

## Other functionalities
### Renaming dimensions
The user can rename the dimensions of the model

```{r}
views_names(model) <- c("Transcriptomics", "Proteomics")
factors_names(model) <- paste("Factor", 1:get_dimensions(model)$K, sep = "")
```

### Extracting data for downstream analysis 
The user can extract the feature weights, the data and the factors to generate their own plots.  

Extract factors

```{r}
# factors is a list of matrices, one matrix per group with dimensions (nsamples, nfactors)
factors <- get_factors(model, factors = "all")
lapply(factors, dim)
```

Extract weights
```{r}
# weight is a list of matrices, one matrix per view with dimensions (nfeatures, nfactors)
weights <- get_weights(model, views = "all", factors = "all")
weights %>% lapply(dim)
```

Extract data 
```{r}
# data is a nested list of matrices, one matrix per view and group with dimensions (nfeatures, nsamples)
data <- get_data(model)
data %>% lapply(function(x){lapply(x, dim)})
```

For convenience, the user can extract the data in long data.frame format:  
```{r}
factors <- get_factors(model, as.data.frame = T)
factors %>% head
```

```{r}
weights <- get_weights(model, as.data.frame = TRUE)
weights %>% head
```

```{r}
data <- get_data(model, as.data.frame = TRUE)
data %>% head
```







