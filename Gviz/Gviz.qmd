---
title: "Gviz"
author: "YinCY"
format: html
editor: source
---

# Introduction
In order to make sense of genomic data one often aims to plot such data in a genome browser, along with a variety of genomic annotation features, such as gene or transcript models, `CpG` island, repeat regions, and so on. These features may either be extracted from public data bases like ENSEMBL or UCSC, or they may be generated or curated in-house. Many of the currently available genome browsers do a reasonable job in displaying genome annotation data, and there are options to connect to some of them from within `R` (e.g., using the `rtracklayer` package). However, none of these solutions offer the flexibility of the full `R` graphics system to display large numeric data in a multitude of different ways. The `Gviz` package (Hahne and Ivanek 2016) aims to close this gap by providing a structured visualization framework to plot any type of data along genomic coordinates. It is loosely based on the `GenomeGraphs` package by Steffen Durinck and James Bullard, however the complete class hierarchy as well as all the plotting methods have been restructured in order to increase performance and flexibility. All plotting is done using the grid graphics system, and several specialized annotation classes allow to integrate publicly available genomic annotation data from sources like `UCSC` or `ENSEMBL`.

# Basic Features
The fundamental concept behind the `Gviz` package is similar to the approach taken by most genome browsers, in that **individual types of genomic features or data are represented by separate tracks**. Within the package, each track constitutes a single object inheriting from class `GdObject`, and there are constructor functions as well as a broad range of methods to interact with and to plot these tracks. **When combining multiple objects, the individual tracks will always share the same genomic coordinate system, thus taking the burden of aligning the plot elements from the user**.

It is worth mentioning that, at a given time, tracks in the sense of the Gviz package are only defined for a single chromosome on a specific genome, at least for the duration of a given plotting operation. You will later see that a track may still contain information for multiple chromosomes, however most of this is hidden except for the currently active chromosome, and the user will have to explicitly switch the chromosome to access the inactive parts. While the package in principle imposes no fixed structure on the chromosome or on the genome names, it makes sense to stick to a standardized naming paradigm, in particular when fetching additional annotation information from online resources. By default this is enforced by a global option `ucscChromosomeNames`, which is set during package loading and which causes the package to check all supplied chromosome names for validity in the sense of the UCSC definition (chromosomes have to start with the `chr` string). You may decide to turn this feature off by calling options(`ucscChromosomeNames=FALSE`). For the remainder of this vignette however, we will make use of the UCSC genome and chromosome identifiers, e.g., the `chr7` chromosome on the mouse `mm9` genome.

```{r}
#| message: false
#| warning: false

library(Gviz)
library(GenomicRanges)
library(magrittr)
```

The most simple genomic features consist of start and stop coordinates, possibly overlapping each other. CpG islands or microarray probes are real life examples for this class of features. In the Bioconductor world those are most often represented as run-length encoded vectors, for instance in the `IRanges` and `GRanges` classes. To seamlessly integrate with other Bioconductor packages, we can use the same data structures to generate our track objects. A sample set of CpG island coordinates has been saved in the `cpgIslands` object and we can use that for our first annotation track object. The constructor function `AnnotationTrack` is a convenient helper to create the object.

```{r}
data("cpgIslands")
class(cpgIslands)

cpgIslands
```

```{r}
chr <- cpgIslands %>% seqnames %>% unique %>% as.character
chr %>% str

gen <- cpgIslands %>% genome
atrack <- AnnotationTrack(range = cpgIslands, 
                         name = "CpG")
atrack
```

Please note that the `AnnotationTrack` constructor (as most constructors in this package) is fairly flexible and can accommodate many different types of inputs. For instance, the `start` and `end` coordinates of the annotation features could be passed in as individual arguments start and end, as a `data.frame` or even as an `IRanges` or `GRangesList` object. Furthermore, a whole bunch of coercion methods are available for those package users that prefer the more traditional R coding paradigm, and they should allow operations along the lines of `as(obj, 'AnnotationTrack')`.

With our first track object being created we may now proceed to the plotting. There is a single function `plotTracks` that handles all of this. As we will learn in the remainder of this vignette, `plotTracks` is quite powerful and has a number of very useful additional arguments. For now we will keep things very simple and just plot the single CpG islands annotation track.

```{r}
plotTracks(atrack)
```

As you can see, the resulting graph is not particularly spectacular. There is a title region showing the track’s name on a gray background on the left side of the plot and a data region showing the seven individual CpG islands on the right. This structure is similar for all the available track objects classes and it somewhat mimics the layout of the popular UCSC Genome Browser. If you are not happy with the default settings, the `Gviz` package offers a multitude of options to fine-tune the track appearance.

Apart from the relative distance of the CpG islands, this visualization does not tell us much. One obvious next step would be to indicate the genomic coordinates we are currently looking at in order to provide some reference. For this purpose, the `Gviz` package offers the `GenomeAxisTrack` class. Objects from the class can be created using the constructor function of the same name.

```{r}
gtrack <- GenomeAxisTrack()
```

Since a `GenomeAxisTrack` object is always relative to the other tracks that are plotted, there is little need for additional arguments. Essentially, the object just tells the `plotTracks` function to add a genomic axis to the plot. Nonetheless, it represent a separate annotation track just as the CpG island track does. We can pass this additional track on to `plotTracks` in the form of a list.

```{r}
plotTracks(trackList = list(gtrack, atrack))
```

You may have realized that the genomic axis does not take up half of the available vertical plotting space, but only uses the space necessary to fit the axis and labels. Also the title region for this track is empty. In general, the `Gviz` package tries to find reasonable defaults for all the parameters controlling the look and feel of a plots so that appealing visualizations can be created without too much tinkering. However, all features on the plot including the relative track sizes can also be adjusted manually.

As mentioned before in the beginning of this vignette, a plotted track is always defined for exactly one chromosome on a particular genome. We can include this information in our plot by means of a chromosome ideogram. An ideogram is a simplified visual representation of a chromosome, with the different chromosomal staining bands indicated by color, and the centromere (if present) indicated by the shape. The necessary information to produce this visualization is stored in online data repositories, for instance at UCSC. The `Gviz` package offers very convenient connections to some of these repositories, and the `IdeogramTrack` constructor function is one example for such a connection. With just the information about a valid UCSC genome and chromosome, we can directly fetch the chromosome ideogram information and construct a dedicated track object that can be visualized by `plotTracks`. Please not that you will need an established internet connection for this to work, and that fetching data from UCSC can take quite a long time, depending on the server load. The `Gviz` package tries to cache as much data as possible to reduce the bandwidth in future queries.

```{r}
#| cache: true
itrack <- IdeogramTrack(genome = gen, chromosome = chr)

plotTracks(trackList = list(itrack, gtrack, atrack))
```

Ideogram tracks are the one exception in all of `Gviz`’s track objects in the sense that they are not really displayed on the same coordinate system like all the other tracks. Instead, **the current genomic location is indicated on the chromosome by a red box** (or, as in this case, a red line if the width is too small to fit a box).

So far we have only looked at very basic annotation features and how to give a point of reference to our plots. Naturally, we also want to be able to handle more complex genomic features, such as gene models. One potential use case would be to utilize gene model information from an existing local source. Alternatively, we could download such data from one of the available online resources like UCSC or ENSEBML, and there are constructor functions to handle these tasks. For this example we are going to load gene model data from a stored `data.frame`. The track class of choice here is a `GeneRegionTrack` object, which can be created via the constructor function of the same name. Similar to the `AnnotationTrack` constructor there are multiple possible ways to pass in the data.

```{r}
data("geneModels")
geneModels
```

```{r}
grtrack <- GeneRegionTrack(geneModels, genome = gen, 
                          chromosome = chr, 
                          name = "Gene Model")

plotTracks(list(itrack, grtrack, gtrack, atrack))
```

In all those previous examples the plotted genomic range has been determined automatically from the input tracks. Unless told otherwise, the package will always display the region from the leftmost item to the rightmost item in any of the tracks. Of course such a static view on a chromosomal region is of rather limited use. We often want to zoom in or out on a particular plotting region to see more details or to get a broader overview. To that end, `plotTracks` supports the `from` and `to` arguments that let us choose an arbitrary genomic range to plot.

```{r}
plotTracks(list(itrack, grtrack, atrack), 
           from = 26700000, 
           to = 26750000)
```

Another pair of arguments that controls the zoom state are `extend.left` and `extend.right`. Rather than `from` and `to`, those arguments are relative to the currently displayed ranges, and can be used to quickly extend the view on one or both ends of the plot. In addition to positive or negative absolute integer values one can also provide a float value between -1 and 1 which will be interpreted as a zoom factor, i.e., a value of 0.5 will cause zooming in to half the currently displayed range.

```{r}
plotTracks(trackList = list(itrack, gtrack, atrack, grtrack), 
           extend.left = 0.5, 
           extend.right = 1000000)
```

You may have noticed that the layout of the gene model track has changed depending on the zoom level. This is a feature of the `Gviz` package, which automatically tries to find the optimal visualization settings to make best use of the available space. At the same time, when features on a track are too close together to be plotted as separate items with the current device resolution, the package will try to reasonably merge them in order to avoid overplotting.

Often individual ranges on a plot tend to grow quite narrow, in particular when zooming far out, and a couple of tweaks become helpful in order to get nice plots, for instance to drop the bounding borders of the exons.

```{r}
plotTracks(trackList = list(itrack, gtrack, atrack, grtrack), 
           extend.left = 0.5, 
           extend.right = 1000000, 
           col = NULL)
```

When zooming further in it may become interesting to take a look at the actual genomic sequence at a given position, and the `Gviz` package provides the track class SequenceTrack that let’s you do just that. Among several other options it can draw the necessary sequence information from one of the `BSgenome` packages.

```{r}
#| message: false
#| warning: false

library(BSgenome.Hsapiens.UCSC.hg38)

strack <- SequenceTrack(sequence = Hsapiens, 
                        chromosome = chr)

plotTracks(trackList = list(itrack, gtrack, atrack, grtrack, strack), 
           from = 26591822, 
           to = 26591852, 
           cex = 0.8)
```

So far we have replicated the features of a whole bunch of other genome browser tools out there. The real power of the package comes with a rather general track type, the `DataTrack`. `DataTrack` object are essentially run-length encoded numeric vectors or matrices, and we can use them to add all sorts of numeric data to our genomic coordinate plots. There are a whole bunch of different visualization options for these tracks, from dot plots to histograms to box-and-whisker plots. The individual rows in a numeric matrix are considered to be different data groups or samples, and the columns are the raster intervals in the genomic coordinates. Of course, the data points (or rather the data ranges) do not have to be evenly spaced; each column is associated with a particular genomic location. For demonstration purposes we can create a simple `DataTrack` object from randomly sampled data. 

```{r}
set.seed(255)
lim <- c(26700000, 26750000)
coords <- sort(c(lim[1], 
                 sample(seq(from = lim[1], to = lim[2]), 99), 
                 lim[2]))

dat <- runif(100, min = -10, max = 10)
dtrack <- DataTrack(data = dat, 
                    start = coords[-length(coords)], 
                    end = coords[-1], 
                    chromosome = chr, 
                    genome = gen, 
                    name = "uniform")

dtrack
```

```{r}
plotTracks(trackList = list(itrack, gtrack, atrack, grtrack, dtrack), 
           from = lim[1], 
           to = lim[2])
```

The first thing to notice is that the title panel to the right of the plot now contains a y-axis indicating the range of the displayed data. The default plotting type for numeric vectors is a simple dot plot. This is by far not the only visualization option, and in a sense it is wasting quite a lot of information because the run-length encoded ranges are not immediately apparent. We can change the plot type by supplying the `type` argument to `plotTracks`. 

```{r}
plotTracks(trackList = list(itrack, gtrack, grtrack, dtrack), 
           from = lim[1],
           to = lim[2], 
           type = "histogram")
```

As we can see, the data values in the numeric vector are indeed matched to the genomic coordinates of the `DataTrack` object. Such a visualization can be particularly helpful when displaying for instance the coverage of NGS reads along a chromosome, or to show the measurement values of mapped probes from a micro array experiment.


## type of tracks
```{r}
grep("Track$", ls("package:Gviz"), value = TRUE) %>% sort
```


# Plotting parameters
## Setting parameters
Although not implicitly mentioned before, we have already made use of the plotting parameter facilities in the `Gviz` package, or, as we will call them from now on, the ‘display parameters’. Display parameters are properties of individual track objects (i.e., of any object inheriting from the base `GdObject` class). They can either be set during object instantiation as additional arguments to the constructor functions or, for existing track objects, using the `displayPars` replacement method. In the former case, all named arguments that can not be matched to any of the constructor’s formal arguments are considered to be display parameters, regardless of their type or whether they are defined for a particular track class or not. The following code example rebuilds our `GeneRegionTrack` object with a bunch of display parameters and demonstrates the use of the `displayPars` accessor and replacement methods.

```{r}
grtrack <- GeneRegionTrack(geneModels, 
                           genome = gen, 
                           chromosome = chr, 
                           name = "Gene Model", 
                           transcriptAnnotation = "symbol", 
                           background.title = "brown")

displayPars(grtrack) %>% head

displayPars(grtrack) <- list(background.panel = "#FFFEDB", col = NULL)

displayPars(grtrack) %>% head

plotTracks(trackList = list(itrack, gtrack, atrack, grtrack))
```

For our gene model track we have now added the gene symbols of the different transcripts to the plot, removed the gray border around the individual exons models, and changed the background color of both the title and the data panel to a yellowish hue. There is a third option to set display parameters for a single plotting operation (rather than the permanent setting in the track object) by passing in additional arguments to the plotTracks function. We have already made use of this feature, for instance in the previous data plotting type example. It is worth mentioning that all display parameters which are passed along with the plotTracks function apply to all track objects in the plot. For some objects classes a particular display parameter may not make any sense, and in that case it is simply ignored. Also, the settings only apply for one single plotting operation and will not be retained in the plotted track objects. They do however get precedence over the object-internal parameters. The following line of code exemplifies this behavior.

```{r}
plotTracks(trackList = list(itrack, gtrack, atrack, grtrack), 
           background.panel = "#FFFEDB", 
           background.title = "darkblue")
```

In order to make full use of the flexible parameter system we need to know which display parameters control which aspect of which track class. The obvious source for this information are the man pages of the respective track classes, which list all available parameters along with a short description of their effect and default values in the `Display Parameters` section. Alternatively, we can use the `availableDisplayPars` function, which prints out the available parameters for a class as well as their default values in a list-like structure. The single argument to the function is either a class name of a track object class, or the object itself, in which case its class is automatically detected.

```{r}
dp <- availableDisplayPars(grtrack)
dp %>% class
dp %>% tail
```

## Schemes
Users might find themselves changing the same parameters over and over again, and it would make sense to register these modifications in a central location once and for all. To this end the `Gviz` package supports display parameter schemes. A scheme is essentially just a bunch of nested named lists, where the names on the first level of nesting should correspond to track class names, and the names on the second level to the display parameters to set. The currently active scheme can be changed by setting the global option `Gviz.scheme`, and a new scheme can be registered by using the `addScheme` function, providing both the list and the name for the new scheme. The `getScheme` function is useful to get the current scheme as a list structure, for instance to use as a skeleton for your own custom scheme.

```{r}
getOption("Gviz.scheme")
scheme <- getScheme()
scheme$GeneRegionTrack$fill <- "salmon"
scheme$GeneRegionTrack$col <- NULL
scheme$GeneRegionTrack$transcriptAnnotation <- "transcript"
addScheme(scheme = scheme, name = "myScheme")

options(Gviz.scheme = "myScheme")

grtrack <- GeneRegionTrack(range = geneModels, 
                           genome = gen, 
                           chromosome = chr, 
                           name = "Gene Model")

plotTracks(list(itrack, grtrack))
```


```{r}
options(Gviz.scheme = "default")
grtrack <- GeneRegionTrack(range = geneModels, 
                           genome = gen, 
                           chromosome = chr, 
                           name = "Gene Model", 
                           transcriptAnnotation = "symbol")

plotTracks(list(itrack, grtrack))
```

In order to make these settings persistent across R sessions one can create one or several schemes in the global environment in the special object `.GvizSchemes`, for instance by putting the necessary code in the `.Rprofile` file. This object needs to be a named list of schemes, and it will be collected when the `Gviz` package loads. Its content is then automatically added to the collection of available schemes. The following pseudo-code exemplifies this and could go into an `.Rprofile` file.

```{r}
#| eval: false

.GvizSchemes <- list(myScheme = list(
    GeneRegionTrack = list(fill = "salmon", 
                           col = NULL, 
                           transcriptAnnotation = "transcript")
))
```


## Plotting direction
By default all tracks will be plotted in a 5’ -> 3’ direction. It sometimes can be useful to actually show the data relative to the opposite strand. To this end one can use the `reverseStrand` display parameter, which does just what its name suggests. Since the combination of forward and reverse stranded tracks on a single plot does not make too much sense, one should usually set this as a global display parameter in the `plotTracks` function. The function will however cast a warning if a mixture of forward and reverse strand tracks has been passed in for plotting.

```{r}
plotTracks(trackList = list(itrack, gtrack, atrack, grtrack), 
           reverseStrand = TRUE)
```


# Track classes
## GenomeAxisTrack
`GenomeAxisTrack` objects can be used to add some reference to the currently displayed genomic location to a `Gviz` plot. In their most basic form they are really just a horizontal axis with genomic coordinate tick-marks. Using the `GenomeAxisTrack` constructor function is the recommended way to instantiate objects from the class. There is no need to know in advance about a particular genomic location when constructing the object. Instead, the displayed coordinates will be determined from the context, e.g., from the `from` and `to` arguments of the `plotTracks` function, or, when plotted together with other track objects, from their genomic locations.

```{r}
axisTrack <- GenomeAxisTrack()
plotTracks(axisTrack, from = 1e6, to = 9e6)
```

As an optional feature one can highlight particular regions on the axis, for instance to indicated stretches of N nucleotides or gaps in genomic alignments. Such regions have to be supplied to the optional `range` argument of the constructor function as either an `GRanges` or an `IRanges` object.

```{r}
axisTrack <- GenomeAxisTrack(range = IRanges(start = c(2e6, 4e6), 
                                             end = c(3e6, 7e6), 
                                             names = rep("N-stretch", 2)))
plotTracks(axisTrack, from = 1e6, to = 9e6, showId = TRUE)
```

### Display parameters for GenomeAxisTrack objects
There are a whole bunch of display parameters to alter the appearance of `GenomeAxisTrack` plots. For instance, one could add directional indicators to the axis using the `add53` and `add35` parameters.

```{r}
plotTracks(axisTrack, from = 1e6, to = 9e6, 
           add35 = TRUE, 
           add53 = TRUE, 
           littleTicks = TRUE)
```

The Gviz package tries to come up with reasonable defaults for the axis annotation. In our previous example, the genomic coordinates are indicated in megabases. We can control this via the exponent parameter, which takes an integer value greater then zero. The location of the tick marks are displayed as a fraction of `\(10^{exponent}\)`.

```{r}
plotTracks(axisTrack, 
           from = 1e6, 
           to = 9e6, 
           exponent = 4)
```

```{r}
plotTracks(axisTrack, 
           from = 1e6, 
           to = 9e6, 
           labelPos = "alternating")
```

Sometimes a full-blown axis is just too much, and all we really need in the plot is a small scale indicator. We can change the appearance of the `GenomeAxisTrack` object to such a limited representation by setting the `scale` display parameter. Typically, this will be a numeric value between 0 and 1, which is interpreted as the fraction of the plotting region used for the scale. The plotting method will apply some rounding to come up with reasonable and human-readable values. For even more control we can pass in a value larger than 1, which is considered to be an absolute range length. In this case, the user is responsible for the scale to actually fit in the current plotting range.

```{r}
plotTracks(axisTrack, from = 1e6, to = 9e6, scale = 0.5, 
           labelPos = "below", 
           col = "steelblue", 
           fontcolor = "red")
```


## IdeogramTrack
While a genomic axis provides helpful points of reference to a plot, it is sometimes important to show the currently displayed region in the broader context of the whole chromosome. Are we looking at distal regions, or somewhere close to the centromere? And how much of the complete chromosome is covered in our plot. To that end the `Gviz` package defines the `IdeogramTrack` class, which is an idealized representation of a single chromosome. When plotted, these track objects will always show the whole chromosome, regardless of the selected genomic region. However, the displayed coordinates are indicated by a box that sits on the ideogram image. The chromosomal data necessary to draw the ideogram is not part of the `Gviz` package itself, instead it is downloaded from an online source (UCSC). Thus it is important to use both chromosome and genome names that are recognizable in the UCSC data base when dealing with `IdeogramTrack` objects. You might want to consult the UCSC webpage or use the ucscGenomes function in the `rtracklayer` package for a listing of available genomes.

Assuming the chromosome data are available online, a simple call to the `IdeogramTrack` constructor function including the desired genome and chromosome name are enough to instantiate the object. Since the connection to UCSC can be slow, the package tries to cache data that has already been downloaded for the duration of the R session. If needed, the user can manually clear the cache by calling the `clearSessionCache` function. Of course it is also possible to construct `IdeogramTrack` objects from local data. Please see the class’ man page for details.

```{r}
ideoTrack <- IdeogramTrack(genome = "hg19", 
                           chromosome = "chrX")
plotTracks(ideoTrack, 
           from = 85e6, 
           to = 129e6, 
           showId = F, # do not show chromosome name
           showBandId = TRUE,
           cex.bands = 0.5
           )
```

```{r}
plotTracks(ideoTrack, 
           from = 85e6, 
           to = 129e6, 
           showId = F, 
           centromereShape = "circle")
```


## DataTrack
Probably the most powerful of all the track classes in the `Gviz` package are `DataTracks`. Essentially they constitute run-length encoded numeric vectors or matrices, meaning that one or several numeric values are associated to a particular genomic coordinate range. These ranges may even be overlapping, for instance when looking at results from a running window operation. There can be multiple samples in a single data set, in which case the ranges are associated to the columns of a numeric matrix rather than a numeric vector, and the plotting method provides tools to incorporate sample group information. Thus the starting point for creating `DataTrack` objects will always be a set of ranges, either in the form of an `IRanges` or `GRanges` object, or individually as start and end coordinates or widths. The second ingredient is a numeric vector of the same length as the number of ranges, or a numeric matrix with the same number of columns. Those may even already be part of the input `GRanges` object as `elemenMetadata` values. For a complete description of all the possible inputs please see the class’ online documentation. We can pass all this information to the `DataTrack` constructor function to instantiate an object. We will load our sample data from an `GRanges` object that comes as part of the `Gviz` package.

```{r}
data("twoGroups")
dTRack <- DataTrack(range = twoGroups, name = "uniform", type = "boxplot")
plotTracks(dTRack)
```

The `a` type for instance averages the values at each genomic location before plotting the derived values as a line. The decision for a particular plot type is totally up to the user, and one could even overlay multiple types by supplying a character vector rather than a character scalar as the `type` argument. For example, this will combine a boxplot with an average line and a data grid.

```{r}
plotTracks(dTRack, type = c("boxplot", "a", "g"))
```

```{r}
twoGroups %>% mcols %>% colnames()

plotTracks(dTRack, type = c("heatmap"), 
           showSampleNames = TRUE, 
           cex.sampleNames = 0.6)
```

```{r}
plotTracks(dTRack, 
           groups = rep(c("control", "treated"), each = 3),
           type = c("a", "p", "confint"))
```




















